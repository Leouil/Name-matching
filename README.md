# Fuzzy Name-matching
Name matching algorithm for company and people name in English

(1) coname.py will match two sets of Company names in English. The pre-defined company name pattern is for U.S firms, such as Inc, Corp etc..
This algorithm (henceforth "the algo") will allow ONE set of names have uninformative words for counter the extraction errors. For example, suppose you extract some firm names from some texts. Suppose you cannot identify the exact location of the name and extracted "In the case of Microsoft Corp" instead of "Microsoft Corp", the algo is robust to such noice. But you should do your best to obtain clean names to improve accuracy.

(2) Now, I explain the logic behind the algo. First, I recover the common abbreviations used in the names. Currently, the default for U.S firms such as "inc" (incorporation), "corp" (corporation), or "intl" (international). The list I populate is from manually reading the S&P's Compustat database. If you have your own list of abbreviations, please edit in your local branch for your own usage. Next, I will run the token_set_ratio from fuzzywuzzy.fuzz module between two names. This will be the raw score to start with. token_set_ratio does not care about the order the name e.g "United Airline" will matched to "Aireline United". It does not care about additional words e.g. "In the case of Microsoft Corp" will be matched to "Microsoft Corp". In other words, as long as two names are reasonable subset of one of another, the pair will remain in the sample. In addition, it does not care about the cases of the letters and ignore any punctuations. The beauty of using token_set_ratio is that it will give you all the possible matches (with all possible reporting mistakes). I require the score to be more than 60 to remain in the sample. It is highly unlikely that score below 60 will constitute a possible match. The algo will produce a file constitutes all the possible matches ("the match pool"). If you ever find a pair of names should be matched but didn't, you can always check the match pool. This pool will also make the future match process computationally easier by eliminating all the impossible pairs and only test the possible pairs remaining in the pool.

(3) Second, we enforce the order of matched words. Note that the "matched" word does not have to be exact match i.e. "technology" will matched to "technologu" to account for misspelling. I only permit 1 letter difference in 7 letters, e.g. "abcdefg" can be matched to "abcdefz" (1 letter mis-spell) but not "abcdefyz" (2 letter mis-spell). The torlerance can be larger when the word is longer, because the longer is the string, the safer to say they are "matched word". I enforced the order of all matched words.say "Happy Time Ltd" and "Time Happy Ltd" will not be considered as a match because, they are not in the correct order.

(4) Third, I enforce the correct neighbour words of those matched words. For example, "BHP Ltd" will not be matched to "BHP Management Ltd" because the word in between the matched words, or "A tech Corp" will not be matched to "B tech Corp". The neighbour words do not have to exact match, but as long as they are strict ordered subset (there is no additional letter and the letters are in order). For example, "BHP Mgmt Ltd" will be matched to "BHP Management Ltd", because "mgmt" is a strict subset of "Management" and the order of the letters are correct. The rationale is that abbreviations are always the strict ordered subset of the full string. The coding logic is find all relative positions of "mgmt" in "management", which is (1,7),(5),(1,7),(10), for each bracket, as long as one number in the bracket is less than any number in next bracket, the test will pass, with testing all brackets except for last bracket.

(5) A question could arise saying why I do not enforce exact match in the first place. My answer is I do want to correct for extraction errors. In the case "In the case A tech Corp" will still be matched to "A tech Corp" and eliminate all wrong matches by my neighbour words approach but not the exact match approach. Of course, if you have extraction errors in both name lists, my method will not work too well.
