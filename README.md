# Fuzzy Name-matching
Name matching algorithm for company and people name in English

(1) coname.py will match two sets of Company names in English. The pre-defined company name pattern is for U.S firms, such as Inc, Corp etc..
This algorithm (henceforth "the algo") will allow ONE set of names have uninformative words for counter the extraction errors. For example, suppose you extract some firm names from some texts. Suppose you cannot identify the exact location of the name and extracted "In the case of Microsoft Corp" instead of "Microsoft Corp", the algo is robust to such noice. But you should do your best to obtain clean names to improve accuracy.

(2) Now, I explain the logic behind the algo. First, I recover the common abbreviations used in the names. Currently, the default for U.S firms such as "inc" (incorporation), "corp" (corporation), or "intl" (international). The list I populate is from manually reading the S&P's Compustat database. If you have your own list of abbreviations, please edit in your local branch for your own usage. Next, I will run the token_set_ratio from fuzzywuzzy.fuzz module between two names. This will be the raw score to start with. token_set_ratio does not care about the order the name e.g "United Airline" will matched to "Aireline United". It does not care about additional words e.g. "In the case of Microsoft Corp" will be matched to "Microsoft Corp". In other words, as long as two names are reasonable subset of one of another, the pair will remain in the sample. In addition, it does not care about the cases of the letters and ignore any punctuations. The beauty of using token_set_ratio is that it will give you all the possible matches (with all possible reporting mistakes). I require the score to be more than 60 to remain in the sample. It is highly unlikely that score below 60 will constitute a possible match. The algo will produce a file constitutes all the possible matches ("the match pool"). If you ever find a pair of names should be matched but didn't, you can always check the match pool. This pool will also make the future match process computationally easier by eliminating all the impossible pairs and only test the possible pairs remaining in the pool.

(3) Second, we enforce the order of matched words. Note that the "matched" word does not have to be exact match i.e. "technology" will matched to "technologu" to account for misspelling. I only permit 1 letter difference in 7 letters, e.g. "abcdefg" can be matched to "abcdefz" (1 letter mis-spell) but not "abcdefyz" (2 letter mis-spell). The torlerance can be larger when the word is longer, because the longer is the string, the safer to say they are "matched word". I enforced the order of all matched words, say "Happy Time Ltd" and "Time Happy Ltd" will not be considered as a match because, they are not in the correct order.

(4) Third, I enforce the correct neighbour words of those matched words. For example, "BHP Ltd" will NOT be matched to "BHP Management Ltd" because the word in between the matched words, or "A tech Corp" will not be matched to "B tech Corp". The neighbour words do not have to be exact match, but as long as they are strict ordered subset (there is no additional letter and the letters are in order). For example, "BHP Mgmt Ltd" will be matched to "BHP Management Ltd", because "mgmt" is a strict subset of "Management" and the order of the letters are correct. The rationale is that abbreviations are always the strict ordered subset of the full string. The coding logic is find all relative positions of letters of "mgmt" in "management", which is (1,7),(5),(1,7),(10), for each bracket, as long as one number in the bracket is less than any number in next bracket, the test will pass. Such test will performed for all the brackets. In addition, I also require the abbreviation to be at least 3 letters long because the abbreviations are mostly at least 3 letters long. The above described test will be performed for all neighbours of the matched words. If a matched word has no neighbours, I considered as passed. For example, "Microsoft" will be matched to "Microsoft Corp" because matched word in first name has no neighbours.


(5) A question could arise saying why I do not enforce exact match in the first place. My answer is I do want to correct for extraction errors. In the case "In the case A tech Corp" will still be matched to "A tech Corp" and eliminate all wrong matches by my neighbour words approach but not the exact match approach. Of course, if you have extraction errors in both name lists, my method will not work too well.

(6) For the test described in paragraphs (2) to (4), if the test failed to find any valid matched counter party name for one of the names, I perform some permutations on the original string as follows.

(7) First, collect all the capital letters in the string and put them together, this is mainly to capture the abbreviations of the firm name, say "Hewlett Packard Inc" is often abbreviated to "HP Inc". The collection of capital letters (stripped common suffix like Inc and Corp etc.) should allow the two names to match. I then perform test (2) to (4) on them.

(8) If there is still no matched pair for a name, I then collect all the first letters of the words because the non-match may be caused by the wrong cases of the names e.g "HEWLETT PARKARD Inc". The first letter approach can accommendate this error. Note that this is not superior to the capital letter approach (think about "GeneralMotors" where the space is the thing went wrong), but it is a reasonable rescue for those names with wrong cases. I then perform test (2) to (4) on the first letters.

(9) If again, we do not find a matched pair for the name, I perform another permutation. Think about "Net flix Inc" and "netflix Inc", the space is what went wrong. I adjust this error by join every neighbours pair by pair and perform test (2)-(4). For example, The resulting joining pair of "North West Pharmacy Inc" are "Northwest Pharmacy Inc", "North westPharmacy Inc". Note that I do not join the common suffix. The sequence of joining is from left to the right, it means if I do find a matching pair for "Northwest Pharmacy Inc", I will skip all the subsequent joining.
